### 动态规划和贪婪算法
1、最优化原理，也就是最有子结构性质。这指的是一个最优化策略具有这样的性质，无论过去状态和决策如何，对前面的决策所形成的状态而言，余下的决策必须构成最优策略，简单来说就是一个最优化策略的子策略总是最优的，如果一个问题满足最优化原理，就称其有最优子结构性质。  
2、无后效性，指的是某个状态下的决策的收益，只与状态和决策相关，与达到该状态的方式无关。  
3、子问题的重叠性，动态规划将原来指数级的暴力搜索算法改进到了具有多项式时间复杂度的算法，其中的关键在于解决了荣誉，重复计算的问题，这是动态规划算法的根本目的。  
4、总体来说，动态规划算法就是一系列以空间换取时间的算法。
#### 割绳子：
给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n>1并且m>1)每段绳子的长度记为k[0],k[1],...,k[m].请问k[0]*k[1]*...*k[m]可能的最大乘积是多少？  
例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.  
**分析：**
首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，我们有n-1种选择，也就是说第一段绳子的可能长度分别为1,2,3.....，n-1。因此f(n)=max(f(i)*f(n-i))，其中0<i<n。  
这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。  
当绳子的长度为2的时候，只能剪成长度为1的两段，所以f(2) = 1，当n = 3时，容易得出f(3) = 2;  
**代码如下**
```
def solve(n):
    result=[0 for i in range(n)]
    result[0]=1
    result[1]=2
    result[2]=3
    result[3]=4
    other=[0,1,2,4]
    if n<5:   #直接给答案
        return other[n-1]
    for i in range(4,n):  #从绳子长度5开始计算
        max_val=0
        for j in range(int(i/2)):   #从已有数组计算最优解，需循环
            if result[j]*result[i-1-j]>max_val:
                max_val=result[j]*result[i-1-j]
        result[i]=max_val
    return result[n-1]


ss=solve(10)
print(ss)
```
#### 机器人走网格：
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。  
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。  
问总共有多少条不同的路径？  
解： 
1. 只能向下或者向右走。所以当在i=0 或者 j = 0时  等于1 
2. dp[i] [j] = dp[i-1][j] + dp[i][j-1];
代码：
```
class Solution(object):
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        dp = [[int(i == 0) or int(j == 0) for i in range(m)] for j in range(n)]
        for i in range(1,m):
            for j in range(1,n):
                dp[j][i] = dp[j-1][i] +dp[j][i-1]
        return dp[-1][-1]
```

#### Python实现-264.丑数 II
编写一个程序，找出第 n 个丑数。   
丑数就是只包含质因数 2, 3, 5 的正整数。  
**示例**：
输入: n = 10   
输出: 12   
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。  
**说明**:
1.  是丑数。 
2.  n 不超过1690。

**思路**：
动态规划思想。后面的丑数一定是由前面的丑数乘以2、3或5得到。所以第n个丑数一定是由前n-1个数中的某3个丑数（分别记为index2、index3、index5）分别乘以2、3或者5得到的数中的最小数，index2，index3，index5有个特点，即分别乘以2、3、5得到的数一定含有比第n-1个丑数大（可利用反证法：否则第n-1个丑数就是它们当中的一个）最小丑数，即第n个丑数由u[index2]*2、u[index3]*3、u[index5]*5中的最小数得出。让它们分别和第n个丑数比较，若和第n个丑数相等，则更新它们的值。注：一次最少更新一个值（如遇到第n个丑数是6时，index2和index3都要更新）

**代码**
```
class Solution:
    def nthUglyNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n <= 0:
            return False
        t1 = 0
        t2 = 0
        t3 = 0
        res = [1]
        while len(res) < n:
            res.append(min(res[t1]*2, res[t2]*3, res[t3]*5))
            if res[-1] == res[t1]*2:
                t1 += 1
            if res[-1] == res[t2]*3:
                t2 += 1
            if res[-1] == res[t3]*5:
                t3 += 1
        return res[-1]

```