### 动态规划和贪婪算法
1、最优化原理，也就是最有子结构性质。这指的是一个最优化策略具有这样的性质，无论过去状态和决策如何，对前面的决策所形成的状态而言，余下的决策必须构成最优策略，简单来说就是一个最优化策略的子策略总是最优的，如果一个问题满足最优化原理，就称其有最优子结构性质。  
2、无后效性，指的是某个状态下的决策的收益，只与状态和决策相关，与达到该状态的方式无关。  
3、子问题的重叠性，动态规划将原来指数级的暴力搜索算法改进到了具有多项式时间复杂度的算法，其中的关键在于解决了荣誉，重复计算的问题，这是动态规划算法的根本目的。  
4、总体来说，动态规划算法就是一系列以空间换取时间的算法。
#### 例子：
给你一根长度为n的绳子，请把绳子剪成m段 (m和n都是整数，n>1并且m>1)每段绳子的长度记为k[0],k[1],...,k[m].请问k[0]*k[1]*...*k[m]可能的最大乘积是多少？  
例如，当绳子的长度为8时，我们把它剪成长度分别为2,3,3的三段，此时得到的最大乘积是18.  
**分析：**
首先定义函数f(n)为把长度为n的绳子剪成若干段后各段长度乘积的最大值。在剪第一刀时，我们有n-1种选择，也就是说第一段绳子的可能长度分别为1,2,3.....，n-1。因此f(n)=max(f(i)*f(n-i))，其中0<i<n。  
这是一个自上而下的递归公式。由于递归会有大量的不必要的重复计算。一个更好的办法是按照从下而上的顺序计算，也就是说我们先得到f(2),f(3)，再得到f(4),f(5)，直到得到f(n)。  
当绳子的长度为2的时候，只能剪成长度为1的两段，所以f(2) = 1，当n = 3时，容易得出f(3) = 2;  
**代码如下**
```
def solve(n):
    result=[0 for i in range(n)]
    result[0]=1
    result[1]=2
    result[2]=3
    result[3]=4
    other=[0,1,2,4]
    if n<5:   #直接给答案
        return other[n-1]
    for i in range(4,n):  #从绳子长度5开始计算
        max_val=0
        for j in range(int(i/2)):   #从已有数组计算最优解，需循环
            if result[j]*result[i-1-j]>max_val:
                max_val=result[j]*result[i-1-j]
        result[i]=max_val
    return result[n-1]


ss=solve(10)
print(ss)
```
题目：
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。  
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。  
问总共有多少条不同的路径？  
解： 
1. 只能向下或者向右走。所以当在i=0 或者 j = 0时  等于1 
2. dp[i] [j] = dp[i-1][j] + dp[i][j-1];
代码：
```
class Solution(object):
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        dp = [[int(i == 0) or int(j == 0) for i in range(m)] for j in range(n)]
        for i in range(1,m):
            for j in range(1,n):
                dp[j][i] = dp[j-1][i] +dp[j][i-1]
        return dp[-1][-1]
```