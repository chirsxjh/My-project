### 狄克斯特拉算法(Dijkstra )
#### 简介
狄克斯特拉算法(Dijkstra )用于计算出不存在非负权重的情况下，起点到各个节点的最短距离   
就是贪心算法，每次都选择最小的（局部最优）从而最后选择到最短路径（全局最优解）的过程
解决2类问题：
* 从A出发是否存在到达B的路径；
* 从A出发到达B的最短路径(时间最少、或者路径最少等)，事实上最后计算完成后，已经得到了A到各个节点的最短路径了；   

其思路为：
(1) 找出“最便宜”的节点，即可在最短时间内到达的节点。
(2) 更新该节点对应的邻居节点的开销，其含义将稍后介绍。
(3) 重复这个过程，直到对图中的每个节点都这样做了。
(4) 计算最终路径。

#### 例子
![](https://pic3.zhimg.com/80/v2-750e1f75f347e9e555a605f5f530f7a2_hd.jpg)

u是起始点，一共有6个节点，画个表格用于做记录，首先把u放进集合N'中，
**D(v)表示从源点到达v节点的花费，p(v)表示通过这条路径到达v节点所要经过的上一个节点**  
![](https://pic1.zhimg.com/80/v2-e56c208bcff54a98e5c5d8a2f61453fc_hd.jpg)
图中我们可以看到与u相连的有三个节点，分别是v,x,w，把这三条记录进表格中，同时，u点无法直接到达的节点记为∞.  
![](https://pic4.zhimg.com/80/v2-f041bdb283692db2c5c687ddd5a2f0b3_hd.jpg)
看到u到x花费只要1，把它打个标记，下一步我们就拿x节点下手,我们走到x的面前，把x扔进集合N'中去，然后站在x的位置上**查找图中的几个点中哪些和x直接相连而且又不在集合N'中的（已经在集合N'中的就不用记录了**，那就是v,w,y三个节点啦~ 计算一下从u到x再到v/w/y的花费，分别是3/4/2，如果直接写进表格是这样的
![](https://pic3.zhimg.com/80/v2-e422b354f5205e37757d8b850492326e_hd.jpg)
![](https://pic3.zhimg.com/80/v2-750e1f75f347e9e555a605f5f530f7a2_hd.jpg)

蓝色圈里的新增数据是4，比旧的数据5要花费更小，所以可以保留这条记录，但是我们发现，红色圈里，新增的数据3并不是最小消费，所以这里我们继续使用原来的2,u，如下：
![](https://pic3.zhimg.com/80/v2-ade48333662414b46149e657ec51434a_hd.jpg)
到这里，我们和上一步一样，要选择花费最小的路径继续执行，表格中2,u和2,都是最小的，选哪个都可以,选择y节点，重复1步骤，得到下面的表（这里y到v是没有直接路径的，所以采用上一条记录值）
![](https://pic1.zhimg.com/80/v2-faeb8e4be389bcd9bdf1860c6bc2d63c_hd.jpg)
可以看出2,u是最小花费，所以第三步我们去拿v节点下手
![](https://pic3.zhimg.com/80/v2-423a71c97ee47f34b526076a0d6b4ae6_hd.jpg)
![](https://pic3.zhimg.com/80/v2-750e1f75f347e9e555a605f5f530f7a2_hd.jpg)
跟着标记走我们再去找w,这时候除了z节点，其他节点都已经放进集合了，所以只去看到z点的路径花费就好,经过w到z的话，这里新值将会是8,w，而我们已经有了4,y这条更好的路径了，所以8,w扔掉，保留原来记录如下
 ![](https://pic1.zhimg.com/80/v2-b09cdef94eecaf8c90e9a8e30f23f1b0_hd.jpg)
 最后一步
 ![](https://pic1.zhimg.com/80/v2-3c576de099b8cb49adb93a7edd57f548_hd.jpg)
 至此结果已经出来了~就看黄色部分一共有六个节点  
 起点为u到达v节点的最短路径是u-v，花费2；  
 到达x节点的最短路径是u-x，花费1；  
 到达y节点的最短路径是u-x-y，花费2；  
 到达w节点的最短路径是u-x-y-w，花费3；  
 到达z节点的最短路径是u-x-y-z，花费4；    
 PS在表格中写下的数字永远都是从起始节点出发，经过某路径到达某节点的总花费.

